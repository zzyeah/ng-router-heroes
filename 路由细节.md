# 知识点
- 路由模块分为总路由模块和子路由模块
- 路由配置
- CanActivate 守卫（检查路由访问）
- CanActivateChild 守卫（检查子路由访问）。
- CanDeactivate 守卫（在放弃未保存的更改之前请求许可）。
- Resolve 守卫（预先获取路由数据）。
- 惰性加载 NgModule 。
- CanLoad 守卫（在加载功能模块的文件之前检查）。

## 路由模块 
需要明确的是创建路由模块的命令行
- `ng g module moduleName --routing`
- 该命令行直接创建两个文件,`moduleName.module.ts`和`moduleName-routing.module.ts`。

1. 总路由模块一般是app-routing.module.ts
2. 子路由模块一般是在单独类别文件夹中创建的xxx-routing.module.ts
3. 子路由模块不需要插入总路由模块中
4. 子路由模块和总路由模块均放在app.module.ts中(普通情况)，并且imports[]中AppRoutingModule是最后一个,并且位于子路由模块之后

## 路由配置
1. 总路由需要考虑两点:
```ts
{ path: '',   redirectTo: '/heroes', pathMatch: 'full' }, // 重定向
{ path: '**', component: PageNotFoundComponent } // 404
```
   1. 将最初的相对URL('')转换成所需的默认路径: 当输入localhost:8080时,页面跳转到localhost:8080/heroes,这样的情况
   2. 设置404页面跳转: 当跳转到一个未设置路由的路径中,页面无法显示,使页面发生错误。
   
   > 关于这两点的配置: 
   1. redirectTo用于实现第一点功能, pathMatch用于匹配url地址(full表示的是URL地址匹配必须为path,这才能重定向对应路径)
   2. **则为通配符,当地址栏指向无效的URL则指向对应组件

2. 子路由需要考虑的几个点
   1. 需要展示的页面有哪些
   2. 路径是否需要携带参数, 如果需要,在页面跳转的时候需加上参数`[routerLink]="['/路径', 实参]"`

3. ActivatedRoute 实战
```ts
this.hero$ = this.route.paramMap.pipe(
   switchMap((params: ParamMap) =>
   this.service.getHero(params.get('id')!))
);
```
   1. ActivatedRoute：用于遍历`RouterState`树并从节点提取信息。
   2. paramMap：主要是为了使用paramMap方法,该方法是为了获取URL的param参数
   3. pipe：然后用pipe方法.pipe(switchMap((params)=>{}))
   4. switchMap：是查看服务请求是否在处理。当用户重新导航到该路由,而服务还在寻找旧的params,SwitchMap会放弃旧的请求然后进行新的params的数据请求
   5. AsyncPipe：用于处理Observable的订阅,hero属性将（重新）设置为检索到的英雄。
   6. 注意：当组件订阅一个可观察对象时，通常会在组件销毁时（ngOnDestory）时取消这个订阅。**但是**，ActivatedRoute 中的可观察对象是一个例外，因为 ActivatedRoute 及其可观察对象与 Router 本身是隔离的。 Router 会在不再需要时销毁这个路由组件，而注入进去的 ActivateRoute 也随之销毁了。
   7. 当不需要Observable的时候，可以使用snapshot（在ActivatedRoute里）。
      1. 使用情景：确定不会复用组件实例，每一次进入组件都是创建一个新的组件实例。**需要明确路由器不会复用该组件**
      2. `const id = this.route.snapshot.paramMap.get('id')!;` `this.hero$ = this.service.getHero(id);`
   8. 返回列表路由需要定义方法,接受参数并传回列表路由中,部分代码:`const heroId = hero ? hero.id : null;` `this.router.nabigate(['/heroes', {id: heroId}])`
   9. 列表组件也需要在初始化(ngOnInit)的时候获取导航栏的值`this.heroes$ = this.route.paramMap.pipe(switchMap(params => {this.selectedId = parseInt(params.get('id')!, 10);return this.service.getHeroes();}));`
      1. ActivatedRoute.paramMap 属性是一个路由参数的 Observable。当用户导航到这个组件时，paramMap 会发射一个新值，其中包含 id。 在 ngOnInit() 中，你订阅了这些值 ，设置到 selectedId，并获取英雄数据。
      2. 只需要用CSS类绑定更新模板,就能有选中效果`[class.selected]="hero.id === selectedId"`

## 路由动作(router Animation)
   1. 首先在全局(app.module.ts)导入BrowserAnimationsModule并添加到import数组中
   2. 在需要路由动画的路由配置对象中添加一个data对象。
   3. 转场是基于states的,需使用来自路由的animation数据为转场提供一个有名字的动画state。
   4. 在根目录创建animation.ts。具体代码查看文件，TODO：未深入思考文件代码。
   5. 需要在根组件(app.component.ts)中导入RouterOutlet,并将4定义的动作导入该组件中
   6. 要使用路由动画,需要将RouterOutlet包装到一个元素中。再把`@routeAnimation`触发器绑定到该元素上。
      1. 为了将`@routeAnimation`转场到指定的状态,需要将`ActivatedRoute`中 的data提供给装饰器中的函数
      2. 根组件页面代码
      3. `<div [@routeAnimation]="getAnimationData(routerOutlet)"><router-outlet #routerOutlet="outlet"></router-outlet></div>`
      4. `@routeAnimation` 属性使用所提供的 `routerOutlet` 引用来绑定到 `getAnimationData()`，因此下一步就要在 AppComponent 中定义那个函数。getAnimationData 函数会根据 ActivatedRoute 所提供的 data 对象返回动画的属性。`animation` 属性会根据你在 animations.ts 中定义 slideInAnimation() 时使用的 `transition` 名称进行匹配。
      5. 代码如下:
      6. `getAnimationData(outlet: RouterOutlet) {return outlet && outlet.activatedRouteData && outlet.activatedRouteData.animation;}`

5. 添加子路由并使用相对路由



6. 路由守卫
   1. 任何用户都能在任何时候导航到任何地方。但有时候出于种种原因需要控制对该应用的不同部分的访问。使用场景:
      1. 该用户可能无权导航到目标组件。
      2. 可能用户得先登录（认证）。
      3. 在显示目标组件前，你可能得先获取某些数据。
      4. 在离开组件前，你可能要先保存修改。
      5. 你可能要询问用户：你是否要放弃本次更改，而不用保存它们？
   2. 路由可以return一个Observable<boolean>或者Promise<boolean>,虽然也可以同步返回,但没必要。
   3. 路由守卫接口
      1. 用`CanActivate`来处理导航到某路由的情况。
      2. 用`CanActivateChild`来处理导航到某子路由的情况。
      3. 用`CanDeactivate`来处理从当前路由离开的情况.
      4. 用`Resolve`在路由激活之前获取路由数据。
      5. 用`CanLoad`来处理异步导航到某特性模块的情况。
   4. `CanActivate`：需要身份验证
      1. 业务逻辑：应用程序通常会根据访问者来决定是否授予某个特性区的访问权。 你可以只对已认证过的用户或具有特定角色的用户授予访问权，还可以阻止或限制用户访问权，直到用户账户激活为止。
   5. `CanActivateChild`：保护子路由
      1. CanActivateChild 会在任何子路由被激活之前运行。
   6. `CanDeactivate`；处理未保存的更改
      1. 帮助决定如何处理未保存的更改，以及如何处理。
